using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.IO.Ports;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace UDP
{
    public class UDPClient
    {
        private const int RECEIVE_DGRAM_RESET_TIMEOUT = 5000;

        private UdpClient udpClient;
        private ConcurrentQueue<byte[]> dgrams;
        private IPEndPoint remoteIpEndPoint;
        private readonly AutoResetEvent waitDataSignal = new AutoResetEvent(false);

        private bool manuallyCreated; // tells if one instance was generated by updlistener
        private bool connected = false;
        private int maxQueueCapacity;

        public bool Connected { get => connected; }
        public IPEndPoint RemoteIPEndPoint { get => remoteIpEndPoint; }

        public UDPClient(IPEndPoint localIpEndPoint)
        {
            manuallyCreated = true;
            udpClient = new UdpClient();
            udpClient.Client.Bind(localIpEndPoint);
        }

        public UDPClient()
        {
            manuallyCreated = true;
            udpClient = new UdpClient();
            udpClient.Client.Bind(new IPEndPoint(IPAddress.Loopback, 0));
        }

        internal UDPClient(UdpClient udpClient, IPEndPoint remoteIpEndPoint, int maxQueueCapacity = 10)
        {
            manuallyCreated = false;
            connected = true;
            dgrams = new ConcurrentQueue<byte[]>();
            waitDataSignal = new AutoResetEvent(false);
            this.udpClient = udpClient;
            this.remoteIpEndPoint = remoteIpEndPoint;
            this.maxQueueCapacity = maxQueueCapacity;
        }

        public void Connect(IPEndPoint remoteIpEndPoint)
        {
            if (manuallyCreated && !Connected)
            {
                udpClient.Connect(remoteIpEndPoint);
                this.remoteIpEndPoint = remoteIpEndPoint;
                this.connected = true;
            }
            else
            {
                throw new Exception("Already connected to a remote host.");
            }
        }

        public void Close()
        {
            if (manuallyCreated && Connected)
            {
                udpClient.Close();
                connected = false;
            }
            else if (!manuallyCreated && Connected)
            {
                connected = false;
            }
            else
            {
                throw new Exception("Already connected to a remote host.");
            }
        }

        public void Send(byte[] data, int bytes)
        {
            if (manuallyCreated)
                udpClient.Send(data, bytes);
            else
                udpClient.Send(data, bytes, remoteIpEndPoint);
        }

        public byte[] Receive()
        {
            byte[] buffer;

            if (!manuallyCreated && Connected)
            {
                while (!dgrams.TryDequeue(out buffer))
                    waitDataSignal.WaitOne(RECEIVE_DGRAM_RESET_TIMEOUT);
            }
            else if (Connected)
            {
                IPEndPoint _ = new IPEndPoint(IPAddress.Any, 0);
                buffer = udpClient.Receive(ref _);
            }
            else
            {
                throw new Exception("Can't receive without specifying a remote host. Try to connect to one before.");
            }

            return buffer;
        }

        internal void WriteInternal(byte[] data)
        {
            if (!manuallyCreated && Connected)
            {
                dgrams.Enqueue(data);
                if (dgrams.Count > maxQueueCapacity)
                {
                    byte[] _;
                    dgrams.TryDequeue(out _);
                }
                waitDataSignal.Set();
            }
            else
            {
                throw new Exception("An connection error occurred.");
            }
        }
    }
}
